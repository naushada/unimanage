/*
 * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChildren, ElementRef, HostBinding, Inject, Input, ViewChild, ViewContainerRef, } from '@angular/core';
import { startWith } from 'rxjs/operators';
import { IfActiveService } from '../../utils/conditional/if-active.service';
import { ClrKeyFocus } from '../../utils/focus/key-focus/key-focus';
import { PopoverHostDirective } from '../../utils/popover/popover-host.directive';
import { TabsLayout } from './enums/tabs-layout.enum';
import { TabsService } from './providers/tabs.service';
import { ClrTab } from './tab';
import { ClrTabOverflowContent } from './tab-overflow-content';
import { TABS_ID, TABS_ID_PROVIDER } from './tabs-id.provider';
import * as i0 from "@angular/core";
import * as i1 from "../../utils/conditional/if-active.service";
import * as i2 from "../../utils/popover/providers/popover-toggle.service";
import * as i3 from "./providers/tabs.service";
import * as i4 from "../../utils/i18n/common-strings.service";
import * as i5 from "../../utils/popover/popover-host.directive";
import * as i6 from "@angular/common";
import * as i7 from "../../icon/icon";
import * as i8 from "../../utils/focus/key-focus/key-focus";
import * as i9 from "./tab-overflow-content";
export class ClrTabs {
    constructor(ifActiveService, toggleService, tabsService, tabsId, commonStrings) {
        this.ifActiveService = ifActiveService;
        this.toggleService = toggleService;
        this.tabsService = tabsService;
        this.tabsId = tabsId;
        this.commonStrings = commonStrings;
        this.subscriptions = [];
        this._tabLinkDirectives = [];
        this.tabLinkElements = [];
        // in order to check focus is triggered by click
        // we are using this _mousedown flag
        this._mousedown = false;
    }
    get overflowPosition() {
        return this._tabLinkDirectives.filter(link => !link.inOverflow).length;
    }
    set tabContentViewContainer(value) {
        this.tabsService.tabContentViewContainer = value;
    }
    set layout(layout) {
        if (Object.keys(TabsLayout)
            .map(key => {
            return TabsLayout[key];
        })
            .indexOf(layout) >= 0) {
            this.tabsService.layout = layout;
        }
    }
    get layout() {
        return this.tabsService.layout;
    }
    get tabLinkDirectives() {
        return this._tabLinkDirectives;
    }
    get activeTabInOverflow() {
        return this.tabsService.overflowTabs.indexOf(this.tabsService.activeTab) > -1;
    }
    get activeTabPosition() {
        return this._tabLinkDirectives.findIndex(link => link.active);
    }
    get isCurrentInOverflow() {
        return this.keyFocus.current >= this.overflowPosition;
    }
    get isVertical() {
        return this.layout === TabsLayout.VERTICAL;
    }
    toggleOverflowOnPosition(position) {
        // we need to check current position to determine
        // whether we need to open the tab overflow or not
        this.toggleService.open = position >= this.overflowPosition;
    }
    set tabOverflowEl(value) {
        this._tabOverflowEl = value && value.nativeElement;
        if (this.toggleService.open && value) {
            // only when tab overflow view element is registered,
            // we need to move the focus to the first item
            this.keyFocus.focusCurrent();
        }
    }
    resetKeyFocusCurrentToActive(event) {
        const keyFocusContainsFocus = this.keyFocus.nativeElement.contains(event.relatedTarget);
        if (!keyFocusContainsFocus && this.keyFocus.current !== this.activeTabPosition) {
            this.keyFocus.current = this.activeTabPosition;
        }
    }
    toggleOverflowOnClick() {
        if (this.isCurrentInOverflow && this.toggleService.open) {
            this.keyFocus.moveTo(this.overflowPosition - 1);
        }
        else {
            this.keyFocus.moveTo(this.overflowPosition);
        }
        // once click handler completes running,
        // reset the _mousedown flag
        this._mousedown = false;
    }
    openOverflowOnFocus() {
        // This method should be called only on keyboard generated focus
        // when the active tab is in the overflow
        if (!this._mousedown && !this.toggleService.open) {
            this.keyFocus.moveTo(this.activeTabPosition);
        }
    }
    closeOnFocusOut(event) {
        if (!this._tabOverflowEl.contains(event.relatedTarget) &&
            this.toggleService.open &&
            !this._mousedown) {
            this.toggleService.open = false;
            // if the focus is out of overflow and lands on the active tab link
            // which is currently visible, set the key focus current to activeTabPosition
            if (this.tabLinkElements[this.activeTabPosition] === event.relatedTarget) {
                this.keyFocus.current = this.activeTabPosition;
            }
        }
    }
    closeOnEscapeKey() {
        // Move current to the last visible focusable item
        this.keyFocus.moveTo(this.overflowPosition - 1);
    }
    closeOnOutsideClick(event, tabOverflowTrigger) {
        // Exit early if the event target is the trigger element itself or element that's inside the trigger element.
        // This is because we have another handler on the tabOverflowTrigger element itself.
        // As this handler method is on the document level so the event bubbles up to it and conflicts
        // with the tabOverflowTrigger handler resulting in opening the tab overflow and closing it right away consecutively.
        if (event.target === tabOverflowTrigger || tabOverflowTrigger.contains(event.target)) {
            return;
        }
        // Move current to the last visible focusable item
        if (!this._tabOverflowEl.contains(event.target) && this.isCurrentInOverflow) {
            this.keyFocus.moveTo(this.overflowPosition - 1);
        }
    }
    listenForTabLinkChanges() {
        return this.tabs.changes.pipe(startWith(this.tabs.map(tab => tab.tabLink))).subscribe(() => {
            this._tabLinkDirectives = this.tabs.map(tab => tab.tabLink);
            this.tabLinkElements = this._tabLinkDirectives.map(tab => tab.el.nativeElement);
        });
    }
    ngAfterContentInit() {
        this.subscriptions.push(this.listenForTabLinkChanges());
        if (typeof this.ifActiveService.current === 'undefined' && this.tabLinkDirectives[0]) {
            this.tabLinkDirectives[0].activate();
        }
        // set initial current position
        this.keyFocus.current = this.activeTabPosition;
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => {
            sub.unsubscribe();
        });
    }
}
ClrTabs.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrTabs, deps: [{ token: i1.IfActiveService }, { token: i2.ClrPopoverToggleService }, { token: i3.TabsService }, { token: TABS_ID }, { token: i4.ClrCommonStringsService }], target: i0.ɵɵFactoryTarget.Component });
ClrTabs.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: ClrTabs, selector: "clr-tabs", inputs: { layout: ["clrLayout", "layout"] }, host: { properties: { "class.tabs-vertical": "this.isVertical" } }, providers: [IfActiveService, TabsService, TABS_ID_PROVIDER], queries: [{ propertyName: "tabs", predicate: ClrTab }], viewQueries: [{ propertyName: "tabContentViewContainer", first: true, predicate: ["tabContentViewContainer"], descendants: true, read: ViewContainerRef, static: true }, { propertyName: "keyFocus", first: true, predicate: ClrKeyFocus, descendants: true, static: true }, { propertyName: "tabOverflowEl", first: true, predicate: ClrTabOverflowContent, descendants: true, read: ElementRef }], hostDirectives: [{ directive: i5.PopoverHostDirective }], ngImport: i0, template: `
    <ul
      class="nav"
      role="tablist"
      [clrKeyFocus]="tabLinkElements"
      clrDirection="both"
      (clrFocusChange)="toggleOverflowOnPosition($event)"
      (focusout)="resetKeyFocusCurrentToActive($event)"
    >
      <!--tab links-->
      <ng-container *ngFor="let link of tabLinkDirectives">
        <ng-container *ngIf="link.tabsId === tabsId && !link.inOverflow">
          <li role="presentation" class="nav-item">
            <ng-container [ngTemplateOutlet]="link.templateRefContainer.template"></ng-container>
          </li>
        </ng-container>
      </ng-container>
      <ng-container *ngIf="tabsService.overflowTabs.length > 0">
        <div class="tabs-overflow bottom-right" role="presentation" [class.open]="toggleService.open">
          <li role="application" class="nav-item">
            <button
              #tabOverflowTrigger
              class="btn btn-link nav-link dropdown-toggle"
              type="button"
              aria-hidden="true"
              [attr.tabindex]="activeTabInOverflow && !toggleService.open ? 0 : -1"
              [class.active]="activeTabInOverflow"
              [class.open]="toggleService.open"
              (mousedown)="_mousedown = true"
              (focus)="openOverflowOnFocus()"
              (click)="toggleOverflowOnClick()"
              [attr.title]="commonStrings.keys.more"
            >
              <cds-icon
                shape="ellipsis-horizontal"
                status="toggleService.open ? 'info' : null"
                [attr.title]="commonStrings.keys.more"
              ></cds-icon>
            </button>
          </li>
          <!--tab links in overflow menu-->
          <clr-tab-overflow-content
            *ngIf="toggleService.open"
            (document:keydown.escape)="closeOnEscapeKey()"
            (document:click)="closeOnOutsideClick($event, tabOverflowTrigger)"
            (focusout)="closeOnFocusOut($event)"
          >
            <ng-container *ngFor="let link of tabLinkDirectives">
              <ng-container
                *ngIf="link.tabsId === tabsId && link.inOverflow"
                [ngTemplateOutlet]="link.templateRefContainer.template"
              ></ng-container>
            </ng-container>
          </clr-tab-overflow-content>
        </div>
      </ng-container>
    </ul>
    <ng-container #tabContentViewContainer></ng-container>
  `, isInline: true, dependencies: [{ kind: "directive", type: i6.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i6.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i7.CdsIconCustomTag, selector: "cds-icon" }, { kind: "component", type: i8.ClrKeyFocus, selector: "[clrKeyFocus]", inputs: ["clrDirection", "clrFocusOnLoad", "clrKeyFocus"], outputs: ["clrFocusChange"] }, { kind: "component", type: i9.ClrTabOverflowContent, selector: "clr-tab-overflow-content" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrTabs, decorators: [{
            type: Component,
            args: [{
                    selector: 'clr-tabs',
                    template: `
    <ul
      class="nav"
      role="tablist"
      [clrKeyFocus]="tabLinkElements"
      clrDirection="both"
      (clrFocusChange)="toggleOverflowOnPosition($event)"
      (focusout)="resetKeyFocusCurrentToActive($event)"
    >
      <!--tab links-->
      <ng-container *ngFor="let link of tabLinkDirectives">
        <ng-container *ngIf="link.tabsId === tabsId && !link.inOverflow">
          <li role="presentation" class="nav-item">
            <ng-container [ngTemplateOutlet]="link.templateRefContainer.template"></ng-container>
          </li>
        </ng-container>
      </ng-container>
      <ng-container *ngIf="tabsService.overflowTabs.length > 0">
        <div class="tabs-overflow bottom-right" role="presentation" [class.open]="toggleService.open">
          <li role="application" class="nav-item">
            <button
              #tabOverflowTrigger
              class="btn btn-link nav-link dropdown-toggle"
              type="button"
              aria-hidden="true"
              [attr.tabindex]="activeTabInOverflow && !toggleService.open ? 0 : -1"
              [class.active]="activeTabInOverflow"
              [class.open]="toggleService.open"
              (mousedown)="_mousedown = true"
              (focus)="openOverflowOnFocus()"
              (click)="toggleOverflowOnClick()"
              [attr.title]="commonStrings.keys.more"
            >
              <cds-icon
                shape="ellipsis-horizontal"
                status="toggleService.open ? 'info' : null"
                [attr.title]="commonStrings.keys.more"
              ></cds-icon>
            </button>
          </li>
          <!--tab links in overflow menu-->
          <clr-tab-overflow-content
            *ngIf="toggleService.open"
            (document:keydown.escape)="closeOnEscapeKey()"
            (document:click)="closeOnOutsideClick($event, tabOverflowTrigger)"
            (focusout)="closeOnFocusOut($event)"
          >
            <ng-container *ngFor="let link of tabLinkDirectives">
              <ng-container
                *ngIf="link.tabsId === tabsId && link.inOverflow"
                [ngTemplateOutlet]="link.templateRefContainer.template"
              ></ng-container>
            </ng-container>
          </clr-tab-overflow-content>
        </div>
      </ng-container>
    </ul>
    <ng-container #tabContentViewContainer></ng-container>
  `,
                    providers: [IfActiveService, TabsService, TABS_ID_PROVIDER],
                    hostDirectives: [PopoverHostDirective],
                }]
        }], ctorParameters: function () { return [{ type: i1.IfActiveService }, { type: i2.ClrPopoverToggleService }, { type: i3.TabsService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TABS_ID]
                }] }, { type: i4.ClrCommonStringsService }]; }, propDecorators: { tabContentViewContainer: [{
                type: ViewChild,
                args: ['tabContentViewContainer', { static: true, read: ViewContainerRef }]
            }], layout: [{
                type: Input,
                args: ['clrLayout']
            }], tabs: [{
                type: ContentChildren,
                args: [ClrTab]
            }], keyFocus: [{
                type: ViewChild,
                args: [ClrKeyFocus, { static: true }]
            }], isVertical: [{
                type: HostBinding,
                args: ['class.tabs-vertical']
            }], tabOverflowEl: [{
                type: ViewChild,
                args: [ClrTabOverflowContent, { read: ElementRef }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL2xheW91dC90YWJzL3RhYnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFFTCxTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixXQUFXLEVBQ1gsTUFBTSxFQUNOLEtBQUssRUFHTCxTQUFTLEVBQ1QsZ0JBQWdCLEdBQ2pCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzQyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDNUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBRXBFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDRDQUE0QyxDQUFDO0FBRWxGLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDdkQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLE9BQU8sQ0FBQztBQUUvQixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7Ozs7Ozs7Ozs7O0FBa0UvRCxNQUFNLE9BQU8sT0FBTztJQXdDbEIsWUFDUyxlQUFnQyxFQUNoQyxhQUFzQyxFQUN0QyxXQUF3QixFQUNQLE1BQWMsRUFDL0IsYUFBc0M7UUFKdEMsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBQ2hDLGtCQUFhLEdBQWIsYUFBYSxDQUF5QjtRQUN0QyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUNQLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDL0Isa0JBQWEsR0FBYixhQUFhLENBQXlCO1FB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eUIsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFO2dCQU0xRSxNQUFNO3NCQURULEtBQUs7dUJBQUMsV0FBVztnQkFnQmUsSUFBSTtzQkFBcEMsZUFBZTt1QkFBQyxNQUFNO2dCQVV2QixRQUFRO3NCQURQLFNBQVM7dUJBQUMsV0FBVyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkF3QnBDLFVBQVU7c0JBRGIsV0FBVzt1QkFBQyxxQkFBcUI7Z0JBYzlCLGFBQWE7c0JBRGhCLFNBQVM7dUJBQUMscUJBQXFCLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIzIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgSG9zdEJpbmRpbmcsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgUXVlcnlMaXN0LFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzdGFydFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcbmltcG9ydCB7IENscktleUZvY3VzIH0gZnJvbSAnLi4vLi4vdXRpbHMvZm9jdXMva2V5LWZvY3VzL2tleS1mb2N1cyc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5pbXBvcnQgeyBQb3BvdmVySG9zdERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvcG9wb3Zlci1ob3N0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyVG9nZ2xlU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvcHJvdmlkZXJzL3BvcG92ZXItdG9nZ2xlLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFic0xheW91dCB9IGZyb20gJy4vZW51bXMvdGFicy1sYXlvdXQuZW51bSc7XG5pbXBvcnQgeyBUYWJzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RhYnMuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJUYWIgfSBmcm9tICcuL3RhYic7XG5pbXBvcnQgeyBDbHJUYWJMaW5rIH0gZnJvbSAnLi90YWItbGluay5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2xyVGFiT3ZlcmZsb3dDb250ZW50IH0gZnJvbSAnLi90YWItb3ZlcmZsb3ctY29udGVudCc7XG5pbXBvcnQgeyBUQUJTX0lELCBUQUJTX0lEX1BST1ZJREVSIH0gZnJvbSAnLi90YWJzLWlkLnByb3ZpZGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRhYnMnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDx1bFxuICAgICAgY2xhc3M9XCJuYXZcIlxuICAgICAgcm9sZT1cInRhYmxpc3RcIlxuICAgICAgW2NscktleUZvY3VzXT1cInRhYkxpbmtFbGVtZW50c1wiXG4gICAgICBjbHJEaXJlY3Rpb249XCJib3RoXCJcbiAgICAgIChjbHJGb2N1c0NoYW5nZSk9XCJ0b2dnbGVPdmVyZmxvd09uUG9zaXRpb24oJGV2ZW50KVwiXG4gICAgICAoZm9jdXNvdXQpPVwicmVzZXRLZXlGb2N1c0N1cnJlbnRUb0FjdGl2ZSgkZXZlbnQpXCJcbiAgICA+XG4gICAgICA8IS0tdGFiIGxpbmtzLS0+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBsaW5rIG9mIHRhYkxpbmtEaXJlY3RpdmVzXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJsaW5rLnRhYnNJZCA9PT0gdGFic0lkICYmICFsaW5rLmluT3ZlcmZsb3dcIj5cbiAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGluay50ZW1wbGF0ZVJlZkNvbnRhaW5lci50ZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidGFic1NlcnZpY2Uub3ZlcmZsb3dUYWJzLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYnMtb3ZlcmZsb3cgYm90dG9tLXJpZ2h0XCIgcm9sZT1cInByZXNlbnRhdGlvblwiIFtjbGFzcy5vcGVuXT1cInRvZ2dsZVNlcnZpY2Uub3BlblwiPlxuICAgICAgICAgIDxsaSByb2xlPVwiYXBwbGljYXRpb25cIiBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICN0YWJPdmVyZmxvd1RyaWdnZXJcbiAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLWxpbmsgbmF2LWxpbmsgZHJvcGRvd24tdG9nZ2xlXCJcbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cImFjdGl2ZVRhYkluT3ZlcmZsb3cgJiYgIXRvZ2dsZVNlcnZpY2Uub3BlbiA/IDAgOiAtMVwiXG4gICAgICAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVwiYWN0aXZlVGFiSW5PdmVyZmxvd1wiXG4gICAgICAgICAgICAgIFtjbGFzcy5vcGVuXT1cInRvZ2dsZVNlcnZpY2Uub3BlblwiXG4gICAgICAgICAgICAgIChtb3VzZWRvd24pPVwiX21vdXNlZG93biA9IHRydWVcIlxuICAgICAgICAgICAgICAoZm9jdXMpPVwib3Blbk92ZXJmbG93T25Gb2N1cygpXCJcbiAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZU92ZXJmbG93T25DbGljaygpXCJcbiAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5rZXlzLm1vcmVcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Y2RzLWljb25cbiAgICAgICAgICAgICAgICBzaGFwZT1cImVsbGlwc2lzLWhvcml6b250YWxcIlxuICAgICAgICAgICAgICAgIHN0YXR1cz1cInRvZ2dsZVNlcnZpY2Uub3BlbiA/ICdpbmZvJyA6IG51bGxcIlxuICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mua2V5cy5tb3JlXCJcbiAgICAgICAgICAgICAgPjwvY2RzLWljb24+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L2xpPlxuICAgICAgICAgIDwhLS10YWIgbGlua3MgaW4gb3ZlcmZsb3cgbWVudS0tPlxuICAgICAgICAgIDxjbHItdGFiLW92ZXJmbG93LWNvbnRlbnRcbiAgICAgICAgICAgICpuZ0lmPVwidG9nZ2xlU2VydmljZS5vcGVuXCJcbiAgICAgICAgICAgIChkb2N1bWVudDprZXlkb3duLmVzY2FwZSk9XCJjbG9zZU9uRXNjYXBlS2V5KClcIlxuICAgICAgICAgICAgKGRvY3VtZW50OmNsaWNrKT1cImNsb3NlT25PdXRzaWRlQ2xpY2soJGV2ZW50LCB0YWJPdmVyZmxvd1RyaWdnZXIpXCJcbiAgICAgICAgICAgIChmb2N1c291dCk9XCJjbG9zZU9uRm9jdXNPdXQoJGV2ZW50KVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgbGluayBvZiB0YWJMaW5rRGlyZWN0aXZlc1wiPlxuICAgICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJsaW5rLnRhYnNJZCA9PT0gdGFic0lkICYmIGxpbmsuaW5PdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwibGluay50ZW1wbGF0ZVJlZkNvbnRhaW5lci50ZW1wbGF0ZVwiXG4gICAgICAgICAgICAgID48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgIDwvY2xyLXRhYi1vdmVyZmxvdy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvdWw+XG4gICAgPG5nLWNvbnRhaW5lciAjdGFiQ29udGVudFZpZXdDb250YWluZXI+PC9uZy1jb250YWluZXI+XG4gIGAsXG4gIHByb3ZpZGVyczogW0lmQWN0aXZlU2VydmljZSwgVGFic1NlcnZpY2UsIFRBQlNfSURfUFJPVklERVJdLFxuICBob3N0RGlyZWN0aXZlczogW1BvcG92ZXJIb3N0RGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFicyBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBwcml2YXRlIGdldCBvdmVyZmxvd1Bvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YWJMaW5rRGlyZWN0aXZlcy5maWx0ZXIobGluayA9PiAhbGluay5pbk92ZXJmbG93KS5sZW5ndGg7XG4gIH1cblxuICBAVmlld0NoaWxkKCd0YWJDb250ZW50Vmlld0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlLCByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIHByaXZhdGUgc2V0IHRhYkNvbnRlbnRWaWV3Q29udGFpbmVyKHZhbHVlOiBWaWV3Q29udGFpbmVyUmVmKSB7XG4gICAgdGhpcy50YWJzU2VydmljZS50YWJDb250ZW50Vmlld0NvbnRhaW5lciA9IHZhbHVlO1xuICB9XG5cbiAgQElucHV0KCdjbHJMYXlvdXQnKVxuICBzZXQgbGF5b3V0KGxheW91dDogVGFic0xheW91dCB8IHN0cmluZykge1xuICAgIGlmIChcbiAgICAgIE9iamVjdC5rZXlzKFRhYnNMYXlvdXQpXG4gICAgICAgIC5tYXAoa2V5ID0+IHtcbiAgICAgICAgICByZXR1cm4gKFRhYnNMYXlvdXQgYXMgUmVjb3JkPHN0cmluZywgYW55Pilba2V5XTtcbiAgICAgICAgfSlcbiAgICAgICAgLmluZGV4T2YobGF5b3V0KSA+PSAwXG4gICAgKSB7XG4gICAgICB0aGlzLnRhYnNTZXJ2aWNlLmxheW91dCA9IGxheW91dDtcbiAgICB9XG4gIH1cbiAgZ2V0IGxheW91dCgpOiBUYWJzTGF5b3V0IHwgc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50YWJzU2VydmljZS5sYXlvdXQ7XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKENsclRhYikgcHJpdmF0ZSB0YWJzOiBRdWVyeUxpc3Q8Q2xyVGFiPjtcblxuICBwcml2YXRlIF90YWJMaW5rRGlyZWN0aXZlczogQ2xyVGFiTGlua1tdID0gW107XG4gIGdldCB0YWJMaW5rRGlyZWN0aXZlcygpOiBDbHJUYWJMaW5rW10ge1xuICAgIHJldHVybiB0aGlzLl90YWJMaW5rRGlyZWN0aXZlcztcbiAgfVxuXG4gIHRhYkxpbmtFbGVtZW50czogSFRNTEVsZW1lbnRbXSA9IFtdO1xuXG4gIEBWaWV3Q2hpbGQoQ2xyS2V5Rm9jdXMsIHsgc3RhdGljOiB0cnVlIH0pXG4gIGtleUZvY3VzOiBDbHJLZXlGb2N1cztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgcHVibGljIHRvZ2dsZVNlcnZpY2U6IENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlLFxuICAgIHB1YmxpYyB0YWJzU2VydmljZTogVGFic1NlcnZpY2UsXG4gICAgQEluamVjdChUQUJTX0lEKSBwdWJsaWMgdGFic0lkOiBudW1iZXIsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlXG4gICkge31cblxuICBnZXQgYWN0aXZlVGFiSW5PdmVyZmxvdygpIHtcbiAgICByZXR1cm4gdGhpcy50YWJzU2VydmljZS5vdmVyZmxvd1RhYnMuaW5kZXhPZih0aGlzLnRhYnNTZXJ2aWNlLmFjdGl2ZVRhYikgPiAtMTtcbiAgfVxuXG4gIGdldCBhY3RpdmVUYWJQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFiTGlua0RpcmVjdGl2ZXMuZmluZEluZGV4KGxpbmsgPT4gbGluay5hY3RpdmUpO1xuICB9XG5cbiAgZ2V0IGlzQ3VycmVudEluT3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5Rm9jdXMuY3VycmVudCA+PSB0aGlzLm92ZXJmbG93UG9zaXRpb247XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnRhYnMtdmVydGljYWwnKVxuICBnZXQgaXNWZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09IFRhYnNMYXlvdXQuVkVSVElDQUw7XG4gIH1cblxuICB0b2dnbGVPdmVyZmxvd09uUG9zaXRpb24ocG9zaXRpb246IG51bWJlcikge1xuICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgY3VycmVudCBwb3NpdGlvbiB0byBkZXRlcm1pbmVcbiAgICAvLyB3aGV0aGVyIHdlIG5lZWQgdG8gb3BlbiB0aGUgdGFiIG92ZXJmbG93IG9yIG5vdFxuICAgIHRoaXMudG9nZ2xlU2VydmljZS5vcGVuID0gcG9zaXRpb24gPj0gdGhpcy5vdmVyZmxvd1Bvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBfdGFiT3ZlcmZsb3dFbDogSFRNTEVsZW1lbnQ7XG5cbiAgQFZpZXdDaGlsZChDbHJUYWJPdmVyZmxvd0NvbnRlbnQsIHsgcmVhZDogRWxlbWVudFJlZiB9KVxuICBzZXQgdGFiT3ZlcmZsb3dFbCh2YWx1ZTogRWxlbWVudFJlZikge1xuICAgIHRoaXMuX3RhYk92ZXJmbG93RWwgPSB2YWx1ZSAmJiB2YWx1ZS5uYXRpdmVFbGVtZW50O1xuICAgIGlmICh0aGlzLnRvZ2dsZVNlcnZpY2Uub3BlbiAmJiB2YWx1ZSkge1xuICAgICAgLy8gb25seSB3aGVuIHRhYiBvdmVyZmxvdyB2aWV3IGVsZW1lbnQgaXMgcmVnaXN0ZXJlZCxcbiAgICAgIC8vIHdlIG5lZWQgdG8gbW92ZSB0aGUgZm9jdXMgdG8gdGhlIGZpcnN0IGl0ZW1cbiAgICAgIHRoaXMua2V5Rm9jdXMuZm9jdXNDdXJyZW50KCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRLZXlGb2N1c0N1cnJlbnRUb0FjdGl2ZShldmVudDogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IGtleUZvY3VzQ29udGFpbnNGb2N1cyA9IHRoaXMua2V5Rm9jdXMubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcbiAgICBpZiAoIWtleUZvY3VzQ29udGFpbnNGb2N1cyAmJiB0aGlzLmtleUZvY3VzLmN1cnJlbnQgIT09IHRoaXMuYWN0aXZlVGFiUG9zaXRpb24pIHtcbiAgICAgIHRoaXMua2V5Rm9jdXMuY3VycmVudCA9IHRoaXMuYWN0aXZlVGFiUG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlT3ZlcmZsb3dPbkNsaWNrKCkge1xuICAgIGlmICh0aGlzLmlzQ3VycmVudEluT3ZlcmZsb3cgJiYgdGhpcy50b2dnbGVTZXJ2aWNlLm9wZW4pIHtcbiAgICAgIHRoaXMua2V5Rm9jdXMubW92ZVRvKHRoaXMub3ZlcmZsb3dQb3NpdGlvbiAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleUZvY3VzLm1vdmVUbyh0aGlzLm92ZXJmbG93UG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8vIG9uY2UgY2xpY2sgaGFuZGxlciBjb21wbGV0ZXMgcnVubmluZyxcbiAgICAvLyByZXNldCB0aGUgX21vdXNlZG93biBmbGFnXG4gICAgdGhpcy5fbW91c2Vkb3duID0gZmFsc2U7XG4gIH1cblxuICAvLyBpbiBvcmRlciB0byBjaGVjayBmb2N1cyBpcyB0cmlnZ2VyZWQgYnkgY2xpY2tcbiAgLy8gd2UgYXJlIHVzaW5nIHRoaXMgX21vdXNlZG93biBmbGFnXG4gIF9tb3VzZWRvd24gPSBmYWxzZTtcblxuICBvcGVuT3ZlcmZsb3dPbkZvY3VzKCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbiBrZXlib2FyZCBnZW5lcmF0ZWQgZm9jdXNcbiAgICAvLyB3aGVuIHRoZSBhY3RpdmUgdGFiIGlzIGluIHRoZSBvdmVyZmxvd1xuICAgIGlmICghdGhpcy5fbW91c2Vkb3duICYmICF0aGlzLnRvZ2dsZVNlcnZpY2Uub3Blbikge1xuICAgICAgdGhpcy5rZXlGb2N1cy5tb3ZlVG8odGhpcy5hY3RpdmVUYWJQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgY2xvc2VPbkZvY3VzT3V0KGV2ZW50OiBGb2N1c0V2ZW50KSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuX3RhYk92ZXJmbG93RWwuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCBhcyBIVE1MRWxlbWVudCkgJiZcbiAgICAgIHRoaXMudG9nZ2xlU2VydmljZS5vcGVuICYmXG4gICAgICAhdGhpcy5fbW91c2Vkb3duXG4gICAgKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB0aGUgZm9jdXMgaXMgb3V0IG9mIG92ZXJmbG93IGFuZCBsYW5kcyBvbiB0aGUgYWN0aXZlIHRhYiBsaW5rXG4gICAgICAvLyB3aGljaCBpcyBjdXJyZW50bHkgdmlzaWJsZSwgc2V0IHRoZSBrZXkgZm9jdXMgY3VycmVudCB0byBhY3RpdmVUYWJQb3NpdGlvblxuICAgICAgaWYgKHRoaXMudGFiTGlua0VsZW1lbnRzW3RoaXMuYWN0aXZlVGFiUG9zaXRpb25dID09PSBldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMua2V5Rm9jdXMuY3VycmVudCA9IHRoaXMuYWN0aXZlVGFiUG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xvc2VPbkVzY2FwZUtleSgpIHtcbiAgICAvLyBNb3ZlIGN1cnJlbnQgdG8gdGhlIGxhc3QgdmlzaWJsZSBmb2N1c2FibGUgaXRlbVxuICAgIHRoaXMua2V5Rm9jdXMubW92ZVRvKHRoaXMub3ZlcmZsb3dQb3NpdGlvbiAtIDEpO1xuICB9XG5cbiAgY2xvc2VPbk91dHNpZGVDbGljayhldmVudDogRXZlbnQsIHRhYk92ZXJmbG93VHJpZ2dlcjogSFRNTEVsZW1lbnQpIHtcbiAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBldmVudCB0YXJnZXQgaXMgdGhlIHRyaWdnZXIgZWxlbWVudCBpdHNlbGYgb3IgZWxlbWVudCB0aGF0J3MgaW5zaWRlIHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGhhdmUgYW5vdGhlciBoYW5kbGVyIG9uIHRoZSB0YWJPdmVyZmxvd1RyaWdnZXIgZWxlbWVudCBpdHNlbGYuXG4gICAgLy8gQXMgdGhpcyBoYW5kbGVyIG1ldGhvZCBpcyBvbiB0aGUgZG9jdW1lbnQgbGV2ZWwgc28gdGhlIGV2ZW50IGJ1YmJsZXMgdXAgdG8gaXQgYW5kIGNvbmZsaWN0c1xuICAgIC8vIHdpdGggdGhlIHRhYk92ZXJmbG93VHJpZ2dlciBoYW5kbGVyIHJlc3VsdGluZyBpbiBvcGVuaW5nIHRoZSB0YWIgb3ZlcmZsb3cgYW5kIGNsb3NpbmcgaXQgcmlnaHQgYXdheSBjb25zZWN1dGl2ZWx5LlxuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRhYk92ZXJmbG93VHJpZ2dlciB8fCB0YWJPdmVyZmxvd1RyaWdnZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1vdmUgY3VycmVudCB0byB0aGUgbGFzdCB2aXNpYmxlIGZvY3VzYWJsZSBpdGVtXG4gICAgaWYgKCF0aGlzLl90YWJPdmVyZmxvd0VsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkgJiYgdGhpcy5pc0N1cnJlbnRJbk92ZXJmbG93KSB7XG4gICAgICB0aGlzLmtleUZvY3VzLm1vdmVUbyh0aGlzLm92ZXJmbG93UG9zaXRpb24gLSAxKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxpc3RlbkZvclRhYkxpbmtDaGFuZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLnRhYnMuY2hhbmdlcy5waXBlKHN0YXJ0V2l0aCh0aGlzLnRhYnMubWFwKHRhYiA9PiB0YWIudGFiTGluaykpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5fdGFiTGlua0RpcmVjdGl2ZXMgPSB0aGlzLnRhYnMubWFwKHRhYiA9PiB0YWIudGFiTGluayk7XG4gICAgICB0aGlzLnRhYkxpbmtFbGVtZW50cyA9IHRoaXMuX3RhYkxpbmtEaXJlY3RpdmVzLm1hcCh0YWIgPT4gdGFiLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMubGlzdGVuRm9yVGFiTGlua0NoYW5nZXMoKSk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPT09ICd1bmRlZmluZWQnICYmIHRoaXMudGFiTGlua0RpcmVjdGl2ZXNbMF0pIHtcbiAgICAgIHRoaXMudGFiTGlua0RpcmVjdGl2ZXNbMF0uYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBjdXJyZW50IHBvc2l0aW9uXG4gICAgdGhpcy5rZXlGb2N1cy5jdXJyZW50ID0gdGhpcy5hY3RpdmVUYWJQb3NpdGlvbjtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiB7XG4gICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9KTtcbiAgfVxufVxuIl19