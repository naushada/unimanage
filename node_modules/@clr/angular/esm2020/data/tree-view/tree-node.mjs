/*
 * Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { animate, state, style, transition, trigger } from '@angular/animations';
import { isPlatformBrowser } from '@angular/common';
import { Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Optional, Output, PLATFORM_ID, SkipSelf, ViewChild, } from '@angular/core';
import { Subject } from 'rxjs';
import { debounceTime, filter } from 'rxjs/operators';
import { IfExpandService } from '../../utils/conditional/if-expanded.service';
import { Keys } from '../../utils/enums/keys.enum';
import { isKeyEitherLetterOrNumber, normalizeKey, preventArrowKeyScroll } from '../../utils/focus/key-focus/util';
import { uniqueIdFactory } from '../../utils/id-generator/id-generator.service';
import { LoadingListener } from '../../utils/loading/loading-listener';
import { DeclarativeTreeNodeModel } from './models/declarative-tree-node.model';
import { ClrSelectedState } from './models/selected-state.enum';
import { TREE_FEATURES_PROVIDER } from './tree-features.service';
import { ClrTreeNodeLink } from './tree-node-link';
import * as i0 from "@angular/core";
import * as i1 from "./tree-features.service";
import * as i2 from "../../utils/conditional/if-expanded.service";
import * as i3 from "../../utils/i18n/common-strings.service";
import * as i4 from "./tree-focus-manager.service";
import * as i5 from "@angular/common";
import * as i6 from "../../icon/icon";
import * as i7 from "./recursive-children";
const LVIEW_CONTEXT_INDEX = 8;
// If the user types multiple keys without allowing 200ms to pass between them,
// then those keys are sent together in one request.
const TREE_TYPE_AHEAD_TIMEOUT = 200;
export class ClrTreeNode {
    constructor(platformId, parent, featuresService, expandService, commonStrings, focusManager, elementRef, injector) {
        this.platformId = platformId;
        this.featuresService = featuresService;
        this.expandService = expandService;
        this.commonStrings = commonStrings;
        this.focusManager = focusManager;
        this.elementRef = elementRef;
        this.STATES = ClrSelectedState;
        this.skipEmitChange = false;
        this.isModelLoading = false;
        this.nodeId = uniqueIdFactory();
        this.typeAheadKeyEvent = new Subject();
        this.typeAheadKeyBuffer = '';
        this.selectedChange = new EventEmitter(false);
        this.expandedChange = new EventEmitter();
        this.subscriptions = [];
        this.contentContainerTabindex = -1;
        if (this.featuresService.recursion) {
            // I'm completely stuck, we have to hack into private properties until either
            // https://github.com/angular/angular/issues/14935 or https://github.com/angular/angular/issues/15998
            // are fixed
            // This is for non-ivy implementations
            if (injector.view) {
                this._model = injector.view.context.clrModel;
            }
            else {
                // Ivy puts this on a specific index of a _lView property
                this._model = injector._lView[LVIEW_CONTEXT_INDEX].clrModel;
            }
        }
        else {
            // Force cast for now, not sure how to tie the correct type here to featuresService.recursion
            this._model = new DeclarativeTreeNodeModel(parent ? parent._model : null);
        }
        this._model.nodeId = this.nodeId;
    }
    isExpandable() {
        if (typeof this.expandable !== 'undefined') {
            return this.expandable;
        }
        return !!this.expandService.expandable || this.isParent;
    }
    isSelectable() {
        return this.featuresService.selectable;
    }
    get selected() {
        return this._model.selected.value;
    }
    set selected(value) {
        this.featuresService.selectable = true;
        // Gracefully handle falsy states like null or undefined because it's just easier than answering questions.
        // This shouldn't happen with strict typing on the app's side, but it's not up to us.
        if (value === null || typeof value === 'undefined') {
            value = ClrSelectedState.UNSELECTED;
        }
        // We match booleans to the corresponding ClrSelectedState
        if (typeof value === 'boolean') {
            value = value ? ClrSelectedState.SELECTED : ClrSelectedState.UNSELECTED;
        }
        // We propagate only if the tree is in smart mode, and skip emitting the output when we set the input
        // See https://github.com/vmware/clarity/issues/3073
        this.skipEmitChange = true;
        this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
        this.skipEmitChange = false;
    }
    get ariaSelected() {
        if (this.isSelectable()) {
            return this._model.selected.value === ClrSelectedState.SELECTED;
        }
        else if (this.treeNodeLink?.active) {
            return true;
        }
        else {
            return null;
        }
    }
    // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
    // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
    // case, you can't use a structural directive, it would need to go on an ng-container.
    get expanded() {
        return this.expandService.expanded;
    }
    set expanded(value) {
        this.expandService.expanded = value;
    }
    set clrForTypeAhead(value) {
        this._model.textContent = trimAndLowerCase(value || this.elementRef.nativeElement.textContent);
    }
    ngOnInit() {
        this._model.expanded = this.expanded;
        this.subscriptions.push(this._model.selected.pipe(filter(() => !this.skipEmitChange)).subscribe(value => {
            this.selectedChange.emit(value);
        }));
        this.subscriptions.push(this.expandService.expandChange.subscribe(value => {
            this.expandedChange.emit(value);
            this._model.expanded = value;
        }));
        this.subscriptions.push(this.focusManager.focusRequest.subscribe(nodeId => {
            if (this.nodeId === nodeId) {
                this.focusTreeNode();
            }
        }), this.focusManager.focusChange.subscribe(nodeId => {
            this.checkTabIndex(nodeId);
        }));
        this.subscriptions.push(this._model.loading$.pipe(debounceTime(0)).subscribe(isLoading => (this.isModelLoading = isLoading)));
    }
    ngAfterContentInit() {
        this.subscriptions.push(this.typeAheadKeyEvent.pipe(debounceTime(TREE_TYPE_AHEAD_TIMEOUT)).subscribe((bufferedKeys) => {
            this.focusManager.focusNodeStartsWith(bufferedKeys, this._model);
            // reset once bufferedKeys are used
            this.typeAheadKeyBuffer = '';
        }));
    }
    ngAfterViewInit() {
        if (!this._model.textContent) {
            this._model.textContent = trimAndLowerCase(this.elementRef.nativeElement.textContent);
        }
    }
    ngOnDestroy() {
        this._model.destroy();
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    get treeNodeLink() {
        return this.treeNodeLinkList && this.treeNodeLinkList.first;
    }
    setTabIndex(value) {
        this.contentContainerTabindex = value;
        this.contentContainer.nativeElement.setAttribute('tabindex', value);
    }
    checkTabIndex(nodeId) {
        if (isPlatformBrowser(this.platformId) && this.nodeId !== nodeId && this.contentContainerTabindex !== -1) {
            this.setTabIndex(-1);
        }
    }
    focusTreeNode() {
        const containerEl = this.contentContainer.nativeElement;
        if (isPlatformBrowser(this.platformId) && document.activeElement !== containerEl) {
            this.setTabIndex(0);
            containerEl.focus();
            containerEl.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        }
    }
    broadcastFocusOnContainer() {
        this.focusManager.broadcastFocusedNode(this.nodeId);
    }
    onKeyDown(event) {
        // Two reasons to prevent default behavior:
        // 1. to prevent scrolling on arrow keys
        // 2. Assistive Technology focus differs from Keyboard focus behavior.
        //    By default, pressing arrow key makes AT focus go into the nested content of the item.
        preventArrowKeyScroll(event);
        // https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-22
        switch (normalizeKey(event.key)) {
            case Keys.ArrowUp:
                this.focusManager.focusNodeAbove(this._model);
                break;
            case Keys.ArrowDown:
                this.focusManager.focusNodeBelow(this._model);
                break;
            case Keys.ArrowRight:
                this.expandOrFocusFirstChild();
                break;
            case Keys.ArrowLeft:
                this.collapseOrFocusParent();
                break;
            case Keys.Home:
                event.preventDefault();
                this.focusManager.focusFirstVisibleNode();
                break;
            case Keys.End:
                event.preventDefault();
                this.focusManager.focusLastVisibleNode();
                break;
            case Keys.Enter:
                this.toggleExpandOrTriggerDefault();
                break;
            case Keys.Space:
            case Keys.Spacebar:
                // to prevent scrolling on space key in this specific case
                event.preventDefault();
                this.toggleExpandOrTriggerDefault();
                break;
            default:
                if (this._model.textContent && isKeyEitherLetterOrNumber(event)) {
                    this.typeAheadKeyBuffer += event.key;
                    this.typeAheadKeyEvent.next(this.typeAheadKeyBuffer);
                    return;
                }
                break;
        }
        // if non-letter keys are pressed, do reset.
        this.typeAheadKeyBuffer = '';
    }
    get isParent() {
        return this._model.children && this._model.children.length > 0;
    }
    toggleExpandOrTriggerDefault() {
        if (this.isExpandable() && !this.isSelectable()) {
            this.expandService.expanded = !this.expanded;
        }
        else {
            this.triggerDefaultAction();
        }
    }
    expandOrFocusFirstChild() {
        if (this.expanded) {
            // if the node is already expanded and has children, focus its very first child
            if (this.isParent) {
                this.focusManager.focusNodeBelow(this._model);
            }
        }
        else {
            // we must check if the node is expandable, in order to set .expanded to true from false
            // because we shouldn't set .expanded to true if it's not expandable node
            if (this.isExpandable()) {
                this.expandService.expanded = true;
            }
        }
    }
    collapseOrFocusParent() {
        if (this.expanded) {
            this.expandService.expanded = false;
        }
        else {
            this.focusManager.focusParent(this._model);
        }
    }
    triggerDefaultAction() {
        if (this.treeNodeLink) {
            this.treeNodeLink.activate();
        }
        else {
            if (this.isSelectable()) {
                this._model.toggleSelection(this.featuresService.eager);
            }
        }
    }
}
ClrTreeNode.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrTreeNode, deps: [{ token: PLATFORM_ID }, { token: ClrTreeNode, optional: true, skipSelf: true }, { token: i1.TreeFeaturesService }, { token: i2.IfExpandService }, { token: i3.ClrCommonStringsService }, { token: i4.TreeFocusManagerService }, { token: i0.ElementRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
ClrTreeNode.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: ClrTreeNode, selector: "clr-tree-node", inputs: { selected: ["clrSelected", "selected"], expandable: ["clrExpandable", "expandable"], expanded: ["clrExpanded", "expanded"], clrForTypeAhead: "clrForTypeAhead" }, outputs: { selectedChange: "clrSelectedChange", expandedChange: "clrExpandedChange" }, host: { properties: { "class.clr-tree-node": "true" } }, providers: [TREE_FEATURES_PROVIDER, IfExpandService, { provide: LoadingListener, useExisting: IfExpandService }], queries: [{ propertyName: "treeNodeLinkList", predicate: ClrTreeNodeLink }], viewQueries: [{ propertyName: "contentContainer", first: true, predicate: ["contentContainer"], descendants: true, read: ElementRef, static: true }], ngImport: i0, template: "<!--\n  ~ Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n  #contentContainer\n  role=\"treeitem\"\n  class=\"clr-tree-node-content-container\"\n  tabindex=\"-1\"\n  [attr.aria-expanded]=\"isExpandable() ? expanded : null\"\n  [attr.aria-selected]=\"ariaSelected\"\n  (keydown)=\"onKeyDown($event)\"\n  (focus)=\"broadcastFocusOnContainer()\"\n>\n  <button\n    *ngIf=\"isExpandable() && !isModelLoading && !expandService.loading\"\n    aria-hidden=\"true\"\n    type=\"button\"\n    tabindex=\"-1\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle();\"\n    (focus)=\"focusTreeNode()\"\n  >\n    <cds-icon\n      class=\"clr-treenode-caret-icon\"\n      shape=\"angle\"\n      [attr.direction]=\"expandService.expanded ? 'down' : 'right'\"\n    ></cds-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || isModelLoading\">\n    <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input\n      aria-hidden=\"true\"\n      type=\"checkbox\"\n      id=\"{{nodeId}}-check\"\n      class=\"clr-checkbox\"\n      [checked]=\"_model.selected.value === STATES.SELECTED\"\n      [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n      (change)=\"_model.toggleSelection(featuresService.eager)\"\n      (focus)=\"focusTreeNode()\"\n      tabindex=\"-1\"\n    />\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\">\n      <ng-container [ngTemplateOutlet]=\"treenodeContent\"></ng-container>\n    </label>\n  </div>\n  <div class=\"clr-treenode-content\" (mousedown)=\"focusTreeNode()\" *ngIf=\"!featuresService.selectable\">\n    <ng-container [ngTemplateOutlet]=\"treenodeContent\"></ng-container>\n  </div>\n\n  <ng-template #treenodeContent>\n    <ng-content></ng-content>\n    <div class=\"clr-sr-only\" *ngIf=\"featuresService.selectable || ariaSelected\">\n      <span *ngIf=\"ariaSelected\"> selected</span>\n      <span *ngIf=\"!ariaSelected\"> unselected</span>\n    </div>\n  </ng-template>\n</div>\n<div\n  class=\"clr-treenode-children\"\n  [@toggleChildrenAnim]=\"expandService.expanded ? 'expanded' : 'collapsed'\"\n  [attr.role]=\"isExpandable() && !featuresService.recursion ? 'group' : null\"\n>\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n", dependencies: [{ kind: "directive", type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i5.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i6.CdsIconCustomTag, selector: "cds-icon" }, { kind: "component", type: i7.RecursiveChildren, selector: "clr-recursive-children", inputs: ["parent", "children"] }], animations: [
        trigger('toggleChildrenAnim', [
            transition('collapsed => expanded', [style({ height: 0 }), animate(200, style({ height: '*' }))]),
            transition('expanded => collapsed', [style({ height: '*' }), animate(200, style({ height: 0 }))]),
            state('expanded', style({ height: '*', 'overflow-y': 'visible' })),
            state('collapsed', style({ height: 0 })),
        ]),
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrTreeNode, decorators: [{
            type: Component,
            args: [{ selector: 'clr-tree-node', providers: [TREE_FEATURES_PROVIDER, IfExpandService, { provide: LoadingListener, useExisting: IfExpandService }], animations: [
                        trigger('toggleChildrenAnim', [
                            transition('collapsed => expanded', [style({ height: 0 }), animate(200, style({ height: '*' }))]),
                            transition('expanded => collapsed', [style({ height: '*' }), animate(200, style({ height: 0 }))]),
                            state('expanded', style({ height: '*', 'overflow-y': 'visible' })),
                            state('collapsed', style({ height: 0 })),
                        ]),
                    ], host: {
                        '[class.clr-tree-node]': 'true',
                    }, template: "<!--\n  ~ Copyright (c) 2016-2023 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n  #contentContainer\n  role=\"treeitem\"\n  class=\"clr-tree-node-content-container\"\n  tabindex=\"-1\"\n  [attr.aria-expanded]=\"isExpandable() ? expanded : null\"\n  [attr.aria-selected]=\"ariaSelected\"\n  (keydown)=\"onKeyDown($event)\"\n  (focus)=\"broadcastFocusOnContainer()\"\n>\n  <button\n    *ngIf=\"isExpandable() && !isModelLoading && !expandService.loading\"\n    aria-hidden=\"true\"\n    type=\"button\"\n    tabindex=\"-1\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle();\"\n    (focus)=\"focusTreeNode()\"\n  >\n    <cds-icon\n      class=\"clr-treenode-caret-icon\"\n      shape=\"angle\"\n      [attr.direction]=\"expandService.expanded ? 'down' : 'right'\"\n    ></cds-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || isModelLoading\">\n    <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input\n      aria-hidden=\"true\"\n      type=\"checkbox\"\n      id=\"{{nodeId}}-check\"\n      class=\"clr-checkbox\"\n      [checked]=\"_model.selected.value === STATES.SELECTED\"\n      [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n      (change)=\"_model.toggleSelection(featuresService.eager)\"\n      (focus)=\"focusTreeNode()\"\n      tabindex=\"-1\"\n    />\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\">\n      <ng-container [ngTemplateOutlet]=\"treenodeContent\"></ng-container>\n    </label>\n  </div>\n  <div class=\"clr-treenode-content\" (mousedown)=\"focusTreeNode()\" *ngIf=\"!featuresService.selectable\">\n    <ng-container [ngTemplateOutlet]=\"treenodeContent\"></ng-container>\n  </div>\n\n  <ng-template #treenodeContent>\n    <ng-content></ng-content>\n    <div class=\"clr-sr-only\" *ngIf=\"featuresService.selectable || ariaSelected\">\n      <span *ngIf=\"ariaSelected\"> selected</span>\n      <span *ngIf=\"!ariaSelected\"> unselected</span>\n    </div>\n  </ng-template>\n</div>\n<div\n  class=\"clr-treenode-children\"\n  [@toggleChildrenAnim]=\"expandService.expanded ? 'expanded' : 'collapsed'\"\n  [attr.role]=\"isExpandable() && !featuresService.recursion ? 'group' : null\"\n>\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: ClrTreeNode, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i1.TreeFeaturesService }, { type: i2.IfExpandService }, { type: i3.ClrCommonStringsService }, { type: i4.TreeFocusManagerService }, { type: i0.ElementRef }, { type: i0.Injector }]; }, propDecorators: { selected: [{
                type: Input,
                args: ['clrSelected']
            }], selectedChange: [{
                type: Output,
                args: ['clrSelectedChange']
            }], expandable: [{
                type: Input,
                args: ['clrExpandable']
            }], expanded: [{
                type: Input,
                args: ['clrExpanded']
            }], clrForTypeAhead: [{
                type: Input,
                args: ['clrForTypeAhead']
            }], expandedChange: [{
                type: Output,
                args: ['clrExpandedChange']
            }], contentContainer: [{
                type: ViewChild,
                args: ['contentContainer', { read: ElementRef, static: true }]
            }], treeNodeLinkList: [{
                type: ContentChildren,
                args: [ClrTreeNodeLink, { descendants: false }]
            }] } });
function trimAndLowerCase(value) {
    return value.toLocaleLowerCase().trim();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZGF0YS90cmVlLXZpZXcvdHJlZS1ub2RlLnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci9zcmMvZGF0YS90cmVlLXZpZXcvdHJlZS1ub2RlLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakYsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUdMLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBRU4sS0FBSyxFQUdMLFFBQVEsRUFDUixNQUFNLEVBQ04sV0FBVyxFQUVYLFFBQVEsRUFDUixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDN0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV0RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDOUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ25ELE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxZQUFZLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUVsSCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sK0NBQStDLENBQUM7QUFDaEYsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxnQkFB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QUFhO2dCQVNoQixlQUFlO3NCQURsQixLQUFLO3VCQUFDLGlCQUFpQjtnQkFLSyxjQUFjO3NCQUExQyxNQUFNO3VCQUFDLG1CQUFtQjtnQkFNbkIsZ0JBQWdCO3NCQUR2QixTQUFTO3VCQUFDLGtCQUFrQixFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQXdEekQsZ0JBQWdCO3NCQUR2QixlQUFlO3VCQUFDLGVBQWUsRUFBRSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUU7O0FBZ0kxRCxTQUFTLGdCQUFnQixDQUFDLEtBQWE7SUFDckMsT0FBTyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUMxQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIzIFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBhbmltYXRlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgUExBVEZPUk1fSUQsXG4gIFF1ZXJ5TGlzdCxcbiAgU2tpcFNlbGYsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBJZkV4cGFuZFNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1leHBhbmRlZC5zZXJ2aWNlJztcbmltcG9ydCB7IEtleXMgfSBmcm9tICcuLi8uLi91dGlscy9lbnVtcy9rZXlzLmVudW0nO1xuaW1wb3J0IHsgaXNLZXlFaXRoZXJMZXR0ZXJPck51bWJlciwgbm9ybWFsaXplS2V5LCBwcmV2ZW50QXJyb3dLZXlTY3JvbGwgfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9rZXktZm9jdXMvdXRpbCc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5pbXBvcnQgeyB1bmlxdWVJZEZhY3RvcnkgfSBmcm9tICcuLi8uLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLWxpc3RlbmVyJztcbmltcG9ydCB7IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL2RlY2xhcmF0aXZlLXRyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBDbHJTZWxlY3RlZFN0YXRlIH0gZnJvbSAnLi9tb2RlbHMvc2VsZWN0ZWQtc3RhdGUuZW51bSc7XG5pbXBvcnQgeyBUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi9tb2RlbHMvdHJlZS1ub2RlLm1vZGVsJztcbmltcG9ydCB7IFRSRUVfRkVBVFVSRVNfUFJPVklERVIsIFRyZWVGZWF0dXJlc1NlcnZpY2UgfSBmcm9tICcuL3RyZWUtZmVhdHVyZXMuc2VydmljZSc7XG5pbXBvcnQgeyBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vdHJlZS1mb2N1cy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyVHJlZU5vZGVMaW5rIH0gZnJvbSAnLi90cmVlLW5vZGUtbGluayc7XG5cbmNvbnN0IExWSUVXX0NPTlRFWFRfSU5ERVggPSA4O1xuXG4vLyBJZiB0aGUgdXNlciB0eXBlcyBtdWx0aXBsZSBrZXlzIHdpdGhvdXQgYWxsb3dpbmcgMjAwbXMgdG8gcGFzcyBiZXR3ZWVuIHRoZW0sXG4vLyB0aGVuIHRob3NlIGtleXMgYXJlIHNlbnQgdG9nZXRoZXIgaW4gb25lIHJlcXVlc3QuXG5jb25zdCBUUkVFX1RZUEVfQUhFQURfVElNRU9VVCA9IDIwMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRyZWUtbm9kZScsXG4gIHRlbXBsYXRlVXJsOiAnLi90cmVlLW5vZGUuaHRtbCcsXG4gIHByb3ZpZGVyczogW1RSRUVfRkVBVFVSRVNfUFJPVklERVIsIElmRXhwYW5kU2VydmljZSwgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBJZkV4cGFuZFNlcnZpY2UgfV0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCd0b2dnbGVDaGlsZHJlbkFuaW0nLCBbXG4gICAgICB0cmFuc2l0aW9uKCdjb2xsYXBzZWQgPT4gZXhwYW5kZWQnLCBbc3R5bGUoeyBoZWlnaHQ6IDAgfSksIGFuaW1hdGUoMjAwLCBzdHlsZSh7IGhlaWdodDogJyonIH0pKV0pLFxuICAgICAgdHJhbnNpdGlvbignZXhwYW5kZWQgPT4gY29sbGFwc2VkJywgW3N0eWxlKHsgaGVpZ2h0OiAnKicgfSksIGFuaW1hdGUoMjAwLCBzdHlsZSh7IGhlaWdodDogMCB9KSldKSxcbiAgICAgIHN0YXRlKCdleHBhbmRlZCcsIHN0eWxlKHsgaGVpZ2h0OiAnKicsICdvdmVyZmxvdy15JzogJ3Zpc2libGUnIH0pKSxcbiAgICAgIHN0YXRlKCdjb2xsYXBzZWQnLCBzdHlsZSh7IGhlaWdodDogMCB9KSksXG4gICAgXSksXG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci10cmVlLW5vZGVdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUcmVlTm9kZTxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgU1RBVEVTID0gQ2xyU2VsZWN0ZWRTdGF0ZTtcbiAgcHJpdmF0ZSBza2lwRW1pdENoYW5nZSA9IGZhbHNlO1xuICBpc01vZGVsTG9hZGluZyA9IGZhbHNlO1xuICBub2RlSWQgPSB1bmlxdWVJZEZhY3RvcnkoKTtcblxuICBwcml2YXRlIHR5cGVBaGVhZEtleUV2ZW50OiBTdWJqZWN0PHN0cmluZz4gPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG5cbiAgcHJpdmF0ZSB0eXBlQWhlYWRLZXlCdWZmZXIgPSAnJztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IGFueSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcGFyZW50OiBDbHJUcmVlTm9kZTxUPixcbiAgICBwdWJsaWMgZmVhdHVyZXNTZXJ2aWNlOiBUcmVlRmVhdHVyZXNTZXJ2aWNlPFQ+LFxuICAgIHB1YmxpYyBleHBhbmRTZXJ2aWNlOiBJZkV4cGFuZFNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgZm9jdXNNYW5hZ2VyOiBUcmVlRm9jdXNNYW5hZ2VyU2VydmljZTxUPixcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIGluamVjdG9yOiBJbmplY3RvclxuICApIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uKSB7XG4gICAgICAvLyBJJ20gY29tcGxldGVseSBzdHVjaywgd2UgaGF2ZSB0byBoYWNrIGludG8gcHJpdmF0ZSBwcm9wZXJ0aWVzIHVudGlsIGVpdGhlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTQ5MzUgb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTU5OThcbiAgICAgIC8vIGFyZSBmaXhlZFxuICAgICAgLy8gVGhpcyBpcyBmb3Igbm9uLWl2eSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgIGlmICgoaW5qZWN0b3IgYXMgYW55KS52aWV3KSB7XG4gICAgICAgIHRoaXMuX21vZGVsID0gKGluamVjdG9yIGFzIGFueSkudmlldy5jb250ZXh0LmNsck1vZGVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXZ5IHB1dHMgdGhpcyBvbiBhIHNwZWNpZmljIGluZGV4IG9mIGEgX2xWaWV3IHByb3BlcnR5XG4gICAgICAgIHRoaXMuX21vZGVsID0gKGluamVjdG9yIGFzIGFueSkuX2xWaWV3W0xWSUVXX0NPTlRFWFRfSU5ERVhdLmNsck1vZGVsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3JjZSBjYXN0IGZvciBub3csIG5vdCBzdXJlIGhvdyB0byB0aWUgdGhlIGNvcnJlY3QgdHlwZSBoZXJlIHRvIGZlYXR1cmVzU2VydmljZS5yZWN1cnNpb25cbiAgICAgIHRoaXMuX21vZGVsID0gbmV3IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbChwYXJlbnQgPyAocGFyZW50Ll9tb2RlbCBhcyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD4pIDogbnVsbCk7XG4gICAgfVxuICAgIHRoaXMuX21vZGVsLm5vZGVJZCA9IHRoaXMubm9kZUlkO1xuICB9XG5cbiAgX21vZGVsOiBUcmVlTm9kZU1vZGVsPFQ+O1xuXG4gIGlzRXhwYW5kYWJsZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZXhwYW5kYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGU7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRhYmxlIHx8IHRoaXMuaXNQYXJlbnQ7XG4gIH1cblxuICBpc1NlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGU7XG4gIH1cblxuICBASW5wdXQoJ2NsclNlbGVjdGVkJylcbiAgZ2V0IHNlbGVjdGVkKCk6IENsclNlbGVjdGVkU3RhdGUgfCBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuc2VsZWN0ZWQudmFsdWU7XG4gIH1cbiAgc2V0IHNlbGVjdGVkKHZhbHVlOiBDbHJTZWxlY3RlZFN0YXRlIHwgYm9vbGVhbikge1xuICAgIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgPSB0cnVlO1xuICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGZhbHN5IHN0YXRlcyBsaWtlIG51bGwgb3IgdW5kZWZpbmVkIGJlY2F1c2UgaXQncyBqdXN0IGVhc2llciB0aGFuIGFuc3dlcmluZyBxdWVzdGlvbnMuXG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIHdpdGggc3RyaWN0IHR5cGluZyBvbiB0aGUgYXBwJ3Mgc2lkZSwgYnV0IGl0J3Mgbm90IHVwIHRvIHVzLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YWx1ZSA9IENsclNlbGVjdGVkU3RhdGUuVU5TRUxFQ1RFRDtcbiAgICB9XG4gICAgLy8gV2UgbWF0Y2ggYm9vbGVhbnMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgQ2xyU2VsZWN0ZWRTdGF0ZVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA/IENsclNlbGVjdGVkU3RhdGUuU0VMRUNURUQgOiBDbHJTZWxlY3RlZFN0YXRlLlVOU0VMRUNURUQ7XG4gICAgfVxuICAgIC8vIFdlIHByb3BhZ2F0ZSBvbmx5IGlmIHRoZSB0cmVlIGlzIGluIHNtYXJ0IG1vZGUsIGFuZCBza2lwIGVtaXR0aW5nIHRoZSBvdXRwdXQgd2hlbiB3ZSBzZXQgdGhlIGlucHV0XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUvY2xhcml0eS9pc3N1ZXMvMzA3M1xuICAgIHRoaXMuc2tpcEVtaXRDaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuX21vZGVsLnNldFNlbGVjdGVkKHZhbHVlLCB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciwgdGhpcy5mZWF0dXJlc1NlcnZpY2UuZWFnZXIpO1xuICAgIHRoaXMuc2tpcEVtaXRDaGFuZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsclNlbGVjdGVkQ2hhbmdlJykgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENsclNlbGVjdGVkU3RhdGU+KGZhbHNlKTtcblxuICBnZXQgYXJpYVNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzU2VsZWN0YWJsZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZWwuc2VsZWN0ZWQudmFsdWUgPT09IENsclNlbGVjdGVkU3RhdGUuU0VMRUNURUQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyZWVOb2RlTGluaz8uYWN0aXZlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gQWxsb3dzIHRoZSBjb25zdW1lciB0byBvdmVycmlkZSBvdXIgbG9naWMgZGVjaWRpbmcgaWYgYSBub2RlIGlzIGV4cGFuZGFibGUuXG4gIC8vIFVzZWZ1bCBmb3IgcmVjdXJzaXZlIHRyZWVzIHRoYXQgZG9uJ3Qgd2FudCB0byBwcmUtbG9hZCBvbmUgbGV2ZWwgYWhlYWQganVzdCB0byBrbm93IHdoaWNoIG5vZGVzIGFyZSBleHBhbmRhYmxlLlxuICBASW5wdXQoJ2NsckV4cGFuZGFibGUnKSBleHBhbmRhYmxlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4gIC8vIEknbSBjYXZpbmcgb24gdGhpcywgZm9yIHRyZWUgbm9kZXMgSSB0aGluayB3ZSBjYW4gdG9sZXJhdGUgaGF2aW5nIGEgdHdvLXdheSBiaW5kaW5nIG9uIHRoZSBjb21wb25lbnRcbiAgLy8gcmF0aGVyIHRoYW4gZW5mb3JjZSB0aGUgY2xySWZFeHBhbmRlZCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBmb3IgZHluYW1pYyBjYXNlcy4gTW9zdGx5IGJlY2F1c2UgZm9yIHRoZSBzbWFydFxuICAvLyBjYXNlLCB5b3UgY2FuJ3QgdXNlIGEgc3RydWN0dXJhbCBkaXJlY3RpdmUsIGl0IHdvdWxkIG5lZWQgdG8gZ28gb24gYW4gbmctY29udGFpbmVyLlxuICBASW5wdXQoJ2NsckV4cGFuZGVkJylcbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQ7XG4gIH1cbiAgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZGVkID0gdmFsdWU7XG4gIH1cblxuICBASW5wdXQoJ2NsckZvclR5cGVBaGVhZCcpXG4gIHNldCBjbHJGb3JUeXBlQWhlYWQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX21vZGVsLnRleHRDb250ZW50ID0gdHJpbUFuZExvd2VyQ2FzZSh2YWx1ZSB8fCB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC50ZXh0Q29udGVudCk7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb250ZW50Q29udGFpbmVyVGFiaW5kZXggPSAtMTtcbiAgQFZpZXdDaGlsZCgnY29udGVudENvbnRhaW5lcicsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiB0cnVlIH0pXG4gIHByaXZhdGUgY29udGVudENvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9tb2RlbC5leHBhbmRlZCA9IHRoaXMuZXhwYW5kZWQ7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9tb2RlbC5zZWxlY3RlZC5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5za2lwRW1pdENoYW5nZSkpLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX21vZGVsLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c1JlcXVlc3Quc3Vic2NyaWJlKG5vZGVJZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVJZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyZWVOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdGhpcy5mb2N1c01hbmFnZXIuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKG5vZGVJZCA9PiB7XG4gICAgICAgIHRoaXMuY2hlY2tUYWJJbmRleChub2RlSWQpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9tb2RlbC5sb2FkaW5nJC5waXBlKGRlYm91bmNlVGltZSgwKSkuc3Vic2NyaWJlKGlzTG9hZGluZyA9PiAodGhpcy5pc01vZGVsTG9hZGluZyA9IGlzTG9hZGluZykpXG4gICAgKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMudHlwZUFoZWFkS2V5RXZlbnQucGlwZShkZWJvdW5jZVRpbWUoVFJFRV9UWVBFX0FIRUFEX1RJTUVPVVQpKS5zdWJzY3JpYmUoKGJ1ZmZlcmVkS2V5czogc3RyaW5nKSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXNNYW5hZ2VyLmZvY3VzTm9kZVN0YXJ0c1dpdGgoYnVmZmVyZWRLZXlzLCB0aGlzLl9tb2RlbCk7XG4gICAgICAgIC8vIHJlc2V0IG9uY2UgYnVmZmVyZWRLZXlzIGFyZSB1c2VkXG4gICAgICAgIHRoaXMudHlwZUFoZWFkS2V5QnVmZmVyID0gJyc7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKCF0aGlzLl9tb2RlbC50ZXh0Q29udGVudCkge1xuICAgICAgdGhpcy5fbW9kZWwudGV4dENvbnRlbnQgPSB0cmltQW5kTG93ZXJDYXNlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9tb2RlbC5kZXN0cm95KCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIC8vIEBDb250ZW50Q2hpbGQgd291bGQgaGF2ZSBiZWVuIG1vcmUgc3VjY2luY3RcbiAgLy8gYnV0IGl0IGRvZXNuJ3Qgb2ZmZXIgYSB3YXkgdG8gcXVlcnkgb25seSBhbiBpbW1lZGlhdGUgY2hpbGRcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJUcmVlTm9kZUxpbmssIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0pXG4gIHByaXZhdGUgdHJlZU5vZGVMaW5rTGlzdDogUXVlcnlMaXN0PENsclRyZWVOb2RlTGluaz47XG5cbiAgZ2V0IHRyZWVOb2RlTGluaygpIHtcbiAgICByZXR1cm4gdGhpcy50cmVlTm9kZUxpbmtMaXN0ICYmIHRoaXMudHJlZU5vZGVMaW5rTGlzdC5maXJzdDtcbiAgfVxuXG4gIHByaXZhdGUgc2V0VGFiSW5kZXgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuY29udGVudENvbnRhaW5lclRhYmluZGV4ID0gdmFsdWU7XG4gICAgdGhpcy5jb250ZW50Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tUYWJJbmRleChub2RlSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIHRoaXMubm9kZUlkICE9PSBub2RlSWQgJiYgdGhpcy5jb250ZW50Q29udGFpbmVyVGFiaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnNldFRhYkluZGV4KC0xKTtcbiAgICB9XG4gIH1cblxuICBmb2N1c1RyZWVOb2RlKCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbnRhaW5lckVsID0gdGhpcy5jb250ZW50Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gY29udGFpbmVyRWwpIHtcbiAgICAgIHRoaXMuc2V0VGFiSW5kZXgoMCk7XG4gICAgICBjb250YWluZXJFbC5mb2N1cygpO1xuICAgICAgY29udGFpbmVyRWwuc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ25lYXJlc3QnLCBpbmxpbmU6ICduZWFyZXN0JyB9KTtcbiAgICB9XG4gIH1cblxuICBicm9hZGNhc3RGb2N1c09uQ29udGFpbmVyKCkge1xuICAgIHRoaXMuZm9jdXNNYW5hZ2VyLmJyb2FkY2FzdEZvY3VzZWROb2RlKHRoaXMubm9kZUlkKTtcbiAgfVxuXG4gIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIC8vIFR3byByZWFzb25zIHRvIHByZXZlbnQgZGVmYXVsdCBiZWhhdmlvcjpcbiAgICAvLyAxLiB0byBwcmV2ZW50IHNjcm9sbGluZyBvbiBhcnJvdyBrZXlzXG4gICAgLy8gMi4gQXNzaXN0aXZlIFRlY2hub2xvZ3kgZm9jdXMgZGlmZmVycyBmcm9tIEtleWJvYXJkIGZvY3VzIGJlaGF2aW9yLlxuICAgIC8vICAgIEJ5IGRlZmF1bHQsIHByZXNzaW5nIGFycm93IGtleSBtYWtlcyBBVCBmb2N1cyBnbyBpbnRvIHRoZSBuZXN0ZWQgY29udGVudCBvZiB0aGUgaXRlbS5cbiAgICBwcmV2ZW50QXJyb3dLZXlTY3JvbGwoZXZlbnQpO1xuXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLXByYWN0aWNlcy0xLjEvI2tleWJvYXJkLWludGVyYWN0aW9uLTIyXG4gICAgc3dpdGNoIChub3JtYWxpemVLZXkoZXZlbnQua2V5KSkge1xuICAgICAgY2FzZSBLZXlzLkFycm93VXA6XG4gICAgICAgIHRoaXMuZm9jdXNNYW5hZ2VyLmZvY3VzTm9kZUFib3ZlKHRoaXMuX21vZGVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleXMuQXJyb3dEb3duOlxuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c05vZGVCZWxvdyh0aGlzLl9tb2RlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlzLkFycm93UmlnaHQ6XG4gICAgICAgIHRoaXMuZXhwYW5kT3JGb2N1c0ZpcnN0Q2hpbGQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleXMuQXJyb3dMZWZ0OlxuICAgICAgICB0aGlzLmNvbGxhcHNlT3JGb2N1c1BhcmVudCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5cy5Ib21lOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleXMuRW5kOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c0xhc3RWaXNpYmxlTm9kZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2V5cy5FbnRlcjpcbiAgICAgICAgdGhpcy50b2dnbGVFeHBhbmRPclRyaWdnZXJEZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlzLlNwYWNlOlxuICAgICAgY2FzZSBLZXlzLlNwYWNlYmFyOlxuICAgICAgICAvLyB0byBwcmV2ZW50IHNjcm9sbGluZyBvbiBzcGFjZSBrZXkgaW4gdGhpcyBzcGVjaWZpYyBjYXNlXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMudG9nZ2xlRXhwYW5kT3JUcmlnZ2VyRGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC50ZXh0Q29udGVudCAmJiBpc0tleUVpdGhlckxldHRlck9yTnVtYmVyKGV2ZW50KSkge1xuICAgICAgICAgIHRoaXMudHlwZUFoZWFkS2V5QnVmZmVyICs9IGV2ZW50LmtleTtcbiAgICAgICAgICB0aGlzLnR5cGVBaGVhZEtleUV2ZW50Lm5leHQodGhpcy50eXBlQWhlYWRLZXlCdWZmZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBpZiBub24tbGV0dGVyIGtleXMgYXJlIHByZXNzZWQsIGRvIHJlc2V0LlxuICAgIHRoaXMudHlwZUFoZWFkS2V5QnVmZmVyID0gJyc7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc1BhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuY2hpbGRyZW4gJiYgdGhpcy5fbW9kZWwuY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgfVxuXG4gIHByaXZhdGUgdG9nZ2xlRXhwYW5kT3JUcmlnZ2VyRGVmYXVsdCgpIHtcbiAgICBpZiAodGhpcy5pc0V4cGFuZGFibGUoKSAmJiAhdGhpcy5pc1NlbGVjdGFibGUoKSkge1xuICAgICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJpZ2dlckRlZmF1bHRBY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGV4cGFuZE9yRm9jdXNGaXJzdENoaWxkKCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAvLyBpZiB0aGUgbm9kZSBpcyBhbHJlYWR5IGV4cGFuZGVkIGFuZCBoYXMgY2hpbGRyZW4sIGZvY3VzIGl0cyB2ZXJ5IGZpcnN0IGNoaWxkXG4gICAgICBpZiAodGhpcy5pc1BhcmVudCkge1xuICAgICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c05vZGVCZWxvdyh0aGlzLl9tb2RlbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIG11c3QgY2hlY2sgaWYgdGhlIG5vZGUgaXMgZXhwYW5kYWJsZSwgaW4gb3JkZXIgdG8gc2V0IC5leHBhbmRlZCB0byB0cnVlIGZyb20gZmFsc2VcbiAgICAgIC8vIGJlY2F1c2Ugd2Ugc2hvdWxkbid0IHNldCAuZXhwYW5kZWQgdG8gdHJ1ZSBpZiBpdCdzIG5vdCBleHBhbmRhYmxlIG5vZGVcbiAgICAgIGlmICh0aGlzLmlzRXhwYW5kYWJsZSgpKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb2xsYXBzZU9yRm9jdXNQYXJlbnQoKSB7XG4gICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgIHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvY3VzTWFuYWdlci5mb2N1c1BhcmVudCh0aGlzLl9tb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyRGVmYXVsdEFjdGlvbigpIHtcbiAgICBpZiAodGhpcy50cmVlTm9kZUxpbmspIHtcbiAgICAgIHRoaXMudHJlZU5vZGVMaW5rLmFjdGl2YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmlzU2VsZWN0YWJsZSgpKSB7XG4gICAgICAgIHRoaXMuX21vZGVsLnRvZ2dsZVNlbGVjdGlvbih0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyaW1BbmRMb3dlckNhc2UodmFsdWU6IHN0cmluZykge1xuICByZXR1cm4gdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKS50cmltKCk7XG59XG4iLCI8IS0tXG4gIH4gQ29weXJpZ2h0IChjKSAyMDE2LTIwMjMgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gIH4gVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAgfiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gIC0tPlxuXG48ZGl2XG4gICNjb250ZW50Q29udGFpbmVyXG4gIHJvbGU9XCJ0cmVlaXRlbVwiXG4gIGNsYXNzPVwiY2xyLXRyZWUtbm9kZS1jb250ZW50LWNvbnRhaW5lclwiXG4gIHRhYmluZGV4PVwiLTFcIlxuICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImlzRXhwYW5kYWJsZSgpID8gZXhwYW5kZWQgOiBudWxsXCJcbiAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJhcmlhU2VsZWN0ZWRcIlxuICAoa2V5ZG93bik9XCJvbktleURvd24oJGV2ZW50KVwiXG4gIChmb2N1cyk9XCJicm9hZGNhc3RGb2N1c09uQ29udGFpbmVyKClcIlxuPlxuICA8YnV0dG9uXG4gICAgKm5nSWY9XCJpc0V4cGFuZGFibGUoKSAmJiAhaXNNb2RlbExvYWRpbmcgJiYgIWV4cGFuZFNlcnZpY2UubG9hZGluZ1wiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICB0YWJpbmRleD1cIi0xXCJcbiAgICBjbGFzcz1cImNsci10cmVlbm9kZS1jYXJldFwiXG4gICAgKGNsaWNrKT1cImV4cGFuZFNlcnZpY2UudG9nZ2xlKCk7XCJcbiAgICAoZm9jdXMpPVwiZm9jdXNUcmVlTm9kZSgpXCJcbiAgPlxuICAgIDxjZHMtaWNvblxuICAgICAgY2xhc3M9XCJjbHItdHJlZW5vZGUtY2FyZXQtaWNvblwiXG4gICAgICBzaGFwZT1cImFuZ2xlXCJcbiAgICAgIFthdHRyLmRpcmVjdGlvbl09XCJleHBhbmRTZXJ2aWNlLmV4cGFuZGVkID8gJ2Rvd24nIDogJ3JpZ2h0J1wiXG4gICAgPjwvY2RzLWljb24+XG4gIDwvYnV0dG9uPlxuICA8ZGl2IGNsYXNzPVwiY2xyLXRyZWVub2RlLXNwaW5uZXItY29udGFpbmVyXCIgKm5nSWY9XCJleHBhbmRTZXJ2aWNlLmxvYWRpbmcgfHwgaXNNb2RlbExvYWRpbmdcIj5cbiAgICA8c3BhbiBjbGFzcz1cImNsci10cmVlbm9kZS1zcGlubmVyIHNwaW5uZXJcIj48L3NwYW4+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiY2xyLWNoZWNrYm94LXdyYXBwZXIgY2xyLXRyZWVub2RlLWNoZWNrYm94XCIgKm5nSWY9XCJmZWF0dXJlc1NlcnZpY2Uuc2VsZWN0YWJsZVwiPlxuICAgIDxpbnB1dFxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICBpZD1cInt7bm9kZUlkfX0tY2hlY2tcIlxuICAgICAgY2xhc3M9XCJjbHItY2hlY2tib3hcIlxuICAgICAgW2NoZWNrZWRdPVwiX21vZGVsLnNlbGVjdGVkLnZhbHVlID09PSBTVEFURVMuU0VMRUNURURcIlxuICAgICAgW2luZGV0ZXJtaW5hdGVdPVwiX21vZGVsLnNlbGVjdGVkLnZhbHVlID09PSBTVEFURVMuSU5ERVRFUk1JTkFURVwiXG4gICAgICAoY2hhbmdlKT1cIl9tb2RlbC50b2dnbGVTZWxlY3Rpb24oZmVhdHVyZXNTZXJ2aWNlLmVhZ2VyKVwiXG4gICAgICAoZm9jdXMpPVwiZm9jdXNUcmVlTm9kZSgpXCJcbiAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgIC8+XG4gICAgPGxhYmVsIGZvcj1cInt7bm9kZUlkfX0tY2hlY2tcIiBjbGFzcz1cImNsci1jb250cm9sLWxhYmVsXCI+XG4gICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRyZWVub2RlQ29udGVudFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbGFiZWw+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiY2xyLXRyZWVub2RlLWNvbnRlbnRcIiAobW91c2Vkb3duKT1cImZvY3VzVHJlZU5vZGUoKVwiICpuZ0lmPVwiIWZlYXR1cmVzU2VydmljZS5zZWxlY3RhYmxlXCI+XG4gICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJ0cmVlbm9kZUNvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgPC9kaXY+XG5cbiAgPG5nLXRlbXBsYXRlICN0cmVlbm9kZUNvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDxkaXYgY2xhc3M9XCJjbHItc3Itb25seVwiICpuZ0lmPVwiZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgfHwgYXJpYVNlbGVjdGVkXCI+XG4gICAgICA8c3BhbiAqbmdJZj1cImFyaWFTZWxlY3RlZFwiPiBzZWxlY3RlZDwvc3Bhbj5cbiAgICAgIDxzcGFuICpuZ0lmPVwiIWFyaWFTZWxlY3RlZFwiPiB1bnNlbGVjdGVkPC9zcGFuPlxuICAgIDwvZGl2PlxuICA8L25nLXRlbXBsYXRlPlxuPC9kaXY+XG48ZGl2XG4gIGNsYXNzPVwiY2xyLXRyZWVub2RlLWNoaWxkcmVuXCJcbiAgW0B0b2dnbGVDaGlsZHJlbkFuaW1dPVwiZXhwYW5kU2VydmljZS5leHBhbmRlZCA/ICdleHBhbmRlZCcgOiAnY29sbGFwc2VkJ1wiXG4gIFthdHRyLnJvbGVdPVwiaXNFeHBhbmRhYmxlKCkgJiYgIWZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24gPyAnZ3JvdXAnIDogbnVsbFwiXG4+XG4gIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci10cmVlLW5vZGVcIj48L25nLWNvbnRlbnQ+XG4gIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJJZkV4cGFuZGVkXVwiPjwvbmctY29udGVudD5cbiAgPGNsci1yZWN1cnNpdmUtY2hpbGRyZW4gW3BhcmVudF09XCJfbW9kZWxcIj48L2Nsci1yZWN1cnNpdmUtY2hpbGRyZW4+XG48L2Rpdj5cbiJdfQ==